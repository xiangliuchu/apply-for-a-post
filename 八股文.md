# 面试八股文

## 写一个单例

### 立即加载

```java
立即加载单例(线程安全)

立即加载: 对象先创建出来,不管你用不用
 */
public class Singleton2 {
    // 提供自身的全局的成员变量
    private static Singleton2 instance = new Singleton2();
    // 构造方法私有

    private Singleton2() {
    }

    // 提供一个public的静态方法,给外部访问使用
    public static Singleton2 getInstance() {
        // 最终要返回唯一的对象
        return instance;
    }
}
```

### 懒加载

```java
/*
懒加载实现单例模式(线程不安全)

 */
public class Singleton {
    // 提供一个全局的自身成员变量
    private static Singleton instance;
    // 构造方法私有

    private Singleton() {
    }

    // 提供一个静态的public的访问,给外部访问,从而获取唯一的实例对象
    public static Singleton getInstance() {
        // 做判断
        if (instance == null) {

            instance = new Singleton();
        }
        // 最终要返回这个唯一的对象
        return instance;
    }
}
```



##  **数据库索引原理和常用的性能优化技术 ：**

待补充 ... 

### 基础知识

1. 三大范式

   原子性、唯一性、数据不要冗余。

2. 聚合函数： count、sum、avg、min、max

3. mysql的字段类型

   **数值类型**：整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）、浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）

   **字符串类型**：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，最常用的是 CHAR 和 VARCHAR。

   **日期时间类型**：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP 等。

   

   ![](https://oss.javaguide.cn/github/javaguide/mysql/summary-of-mysql-field-types.png)



### 数据库高性能优化规范 （看指南）



## redis

### redis双写一致性

本项目中就是用**分布式锁+@around环绕通知**来保证的（强一致性，但是性能要低一些）

![](D:\Java\java50th\java50-course-materials\04-微服务\01-课件\13_商品详情页2\商品详情优化.assets/商品详情页优化-通知.png)

### redis 的操作以及Java中redisson中的操作

#### string

```
# 设置一个键值对（如果key存在，会覆盖）
set key value

# 获取一个键值对的值
get key

# 批量的设置键值对
mset key1 value1 key2 value2 ...

# 批量的获取键值对
mget key1 key2 key3 ...

# 给指定的key的value +1 value必须得是一个数值
incr key

# 给指定的key增加指定的步长
incrby key increment

# 给指定的key的value -1
decr key

# 给指定的key减去指定的步长
decrby key decrement

# 设置一个key-value，并且指定过期时间
setex key seconds value

# set not exists,设置一个键值对，不会覆盖原来的值
# 当key不存在的时候，再去设值，不会覆盖原来的值
setnx key value
```

java客服端是redissonClient.getBucket("number")

```java
   /*
       该方法主要演示对于Redis，string类型数据的访问
   
   */ 
   private static void string(RedissonClient redissonClient) {
		/* 
		     1. number表示String类型的值对应的Redis中的key
		     2. 通过redissonClient获取存放key对应值的Bucket桶
		     3. 桶中放的就是key对应的Redis中的string类型的值
		     4. 对于桶的基本操作就是get/set，获取桶中的值/设置桶中的值
		     5. 对桶中值的操作都相当于是对Redis中key对应的string类型的值的操作 
		 
         */
        RBucket<Integer> bucket = redissonClient.getBucket("number");
        bucket.set(0);

        // 获取对应的String数据类型的值
       Integer result = bucket.get();
        System.out.println(result);
       
        // 获取obj对应的存放String类型值的Bucket桶(这里其实对象被转化成了json字符串)
        RBucket<Person> personBucket = redissonClient.getBucket("obj");
        Person person = new Person();
        person.setName("长风");
        // 向桶中放入对象
        personBucket.set(person);
        
        // 从桶中获取对象
        Person newPerson = personBucket.get();
        System.out.println(newPerson.getName());
       
       
       
    }
```

#### List

```
```









## （待补充）继承和实现有什么区别







## springMVC	

SpringMVC是通过一个Servlet（DispatcherServlet）来接收全部请求，然后分发到不同的方法上



## （待补充）线程池



## 类加载时机

创建类的实例(首次创建该类对象)

访问类的静态变量(首次)

调用类的静态方法(首次)

加载某个类的子类，会先触发父类的加载

直接使用java.exe命令来运行某个主类，也就是执行了某个类的main()方法

**使用反射方式来强制创建某个类或接口对应的java.lang.Class对象**





